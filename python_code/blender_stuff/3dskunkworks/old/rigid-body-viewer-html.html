<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rigid Body Trajectory Viewer - 4 Methods</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            min-height: 100px;
        }
        #resize-handle {
            height: 8px;
            background: #1a1a1a;
            cursor: ns-resize;
            border-top: 2px solid #333;
            border-bottom: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        #resize-handle:hover { background: #2a2a2a; }
        #resize-handle::before {
            content: '⋯';
            color: #666;
            font-size: 20px;
            letter-spacing: 4px;
        }
        #timeseries-container {
            height: 500px;
            background: #0f0f0f;
            padding: 15px;
            overflow-y: auto;
            overflow-x: hidden;
            flex-shrink: 0;
            transition: height 0.3s ease;
        }
        #timeseries-container.collapsed {
            height: 0 !important;
            padding: 0;
            overflow: hidden;
        }
        .charts-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            max-width: 100%;
        }
        .chart {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 10px;
            min-height: 200px;
        }
        .chart-title {
            font-size: 13px;
            font-weight: 600;
            color: #d1d5db;
            margin-bottom: 5px;
            padding-left: 5px;
        }
        #controls {
            background: #1a1a1a;
            border-top: 2px solid #333;
            max-height: 400px;
            overflow-y: auto;
            flex-shrink: 0;
            transition: max-height 0.3s ease;
        }
        #controls.collapsed {
            max-height: 0 !important;
            overflow: hidden;
        }
        #controls-resize-handle {
            height: 8px;
            background: #1a1a1a;
            cursor: ns-resize;
            border-top: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            flex-shrink: 0;
        }
        #controls-resize-handle:hover { background: #2a2a2a; }
        #controls-resize-handle::before {
            content: '⋯';
            color: #666;
            font-size: 20px;
            letter-spacing: 4px;
        }
        .collapse-btn {
            background: #374151;
            border: none;
            color: #9ca3af;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .collapse-btn:hover {
            background: #4b5563;
            color: #d1d5db;
        }
        .control-section { border-bottom: 1px solid #333; }
        .control-section:last-child { border-bottom: none; }
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            cursor: pointer;
            background: #1a1a1a;
            user-select: none;
        }
        .section-header:hover { background: #242424; }
        .section-title {
            font-weight: 600;
            color: #d1d5db;
            font-size: 14px;
        }
        .section-toggle {
            color: #666;
            font-size: 12px;
            transition: transform 0.2s;
        }
        .section-toggle.collapsed { transform: rotate(-90deg); }
        .section-content {
            padding: 0 20px 15px 20px;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        .section-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #1d4ed8; }
        button.reset { background: #4b5563; }
        button.reset:hover { background: #374151; }
        button:disabled {
            background: #374151;
            cursor: not-allowed;
            opacity: 0.5;
        }
        input[type="range"] {
            flex: 1;
            min-width: 150px;
            height: 6px;
            border-radius: 3px;
            background: #374151;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }
        input[type="file"] { display: none; }
        .file-upload-label {
            padding: 8px 16px;
            background: #4b5563;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        .file-upload-label:hover { background: #374151; }
        .file-status {
            font-size: 12px;
            color: #9ca3af;
        }
        .file-status.loaded { color: #4ade80; }
        .file-status.error { color: #f87171; }
        label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .green { color: #4ade80; }
        .red { color: #f87171; }
        .yellow { color: #fbbf24; }
        .purple { color: #c084fc; }
        .blue { color: #60a5fa; }
        .text-sm {
            font-size: 14px;
            white-space: nowrap;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }
        #loadingSpinner {
            border: 4px solid #374151;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .param-label {
            min-width: 100px;
            font-size: 13px;
        }
        .param-value {
            min-width: 50px;
            text-align: right;
            font-size: 13px;
            color: #9ca3af;
        }
        .panel-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 15px;
            background: #242424;
            border-bottom: 1px solid #333;
            font-size: 12px;
            font-weight: 600;
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <div id="loading">
                <div id="loadingSpinner"></div>
                <div id="loadingText">Loading trajectory_data.csv...</div>
            </div>
        </div>

        <div id="resize-handle"></div>

        <div id="timeseries-container">
            <div class="panel-title">
                <span>TIME SERIES PLOTS</span>
                <button class="collapse-btn" id="collapseChartsBtn">▼ Hide</button>
            </div>
            <div class="charts-wrapper">
                <div class="chart">
                    <div class="chart-title">Center Position X (m)</div>
                    <div id="chart-x"></div>
                </div>
                <div class="chart">
                    <div class="chart-title">Center Position Y (m)</div>
                    <div id="chart-y"></div>
                </div>
                <div class="chart">
                    <div class="chart-title">Center Position Z (m)</div>
                    <div id="chart-z"></div>
                </div>
                <div class="chart">
                    <div class="chart-title">Center Position Error (mm)</div>
                    <div id="chart-error"></div>
                </div>
            </div>
        </div>

        <div id="controls-resize-handle">
            <span style="color: #666; font-size: 20px; letter-spacing: 4px;">⋯</span>
            <button class="collapse-btn" id="collapseControlsBtn">▼ Hide Controls</button>
        </div>

        <div id="controls">
            <div class="control-section">
                <div class="section-header" data-section="data">
                    <span class="section-title">Data Source</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="section-content" data-section="data">
                    <div class="control-row">
                        <span class="file-status" id="dataStatus">Attempting auto-load...</span>
                        <label class="file-upload-label" for="csvFile">📁 Upload CSV</label>
                        <input type="file" id="csvFile" accept=".csv">
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-header" data-section="playback">
                    <span class="section-title">Playback Controls</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="section-content" data-section="playback">
                    <div class="control-row">
                        <button id="playBtn" disabled>▶ Play</button>
                        <button class="reset" id="resetBtn" disabled>↻ Reset</button>
                        <input type="range" id="frameSlider" min="0" max="0" value="0" disabled>
                        <span class="text-sm"><span id="currentFrame">0</span> / <span id="totalFrames">0</span></span>
                    </div>
                    <div class="control-row">
                        <span class="param-label">Speed:</span>
                        <input type="range" id="speedSlider" min="0.25" max="4" step="0.25" value="1">
                        <span class="param-value"><span id="speedValue">1</span>x</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-header" data-section="visualization">
                    <span class="section-title">Visualization Settings</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="section-content" data-section="visualization">
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="showGroundTruth" checked>
                            <span class="green">Ground Truth</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showNoisy" checked>
                            <span class="red">Noisy</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showKabsch" checked>
                            <span class="yellow">Kabsch</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showOptNoFilter" checked>
                            <span class="purple">Opt (raw)</span>
                        </label>
                        <label>
                            <input type="checkbox" id="showOptimized" checked>
                            <span class="blue">Opt (filtered)</span>
                        </label>
                    </div>
                    <div class="control-row">
                        <span class="param-label">Trail Length:</span>
                        <input type="range" id="trailLengthSlider" min="0" max="200" value="50">
                        <span class="param-value"><span id="trailLengthValue">50</span></span>
                    </div>
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="showCornerTrailsCheckbox">
                            <span>Show Corner Trails</span>
                        </label>
                    </div>
                    <div class="control-row">
                        <span class="param-label">Point Size:</span>
                        <input type="range" id="pointSizeSlider" min="0.02" max="0.20" step="0.01" value="0.08">
                        <span class="param-value"><span id="pointSizeValue">0.08</span></span>
                    </div>
                    <div class="control-row">
                        <label>
                            <input type="checkbox" id="showGridCheckbox" checked>
                            <span>Show Grid</span>
                        </label>
                        <label>
                            <input type="checkbox" id="autoRotateCheckbox">
                            <span>Auto-Rotate Camera</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script>
        // Collapsible panels
        document.getElementById('collapseChartsBtn').addEventListener('click', () => {
            const container = document.getElementById('timeseries-container');
            const btn = document.getElementById('collapseChartsBtn');
            container.classList.toggle('collapsed');
            btn.textContent = container.classList.contains('collapsed') ? '▲ Show' : '▼ Hide';
        });

        document.getElementById('collapseControlsBtn').addEventListener('click', () => {
            const container = document.getElementById('controls');
            const btn = document.getElementById('collapseControlsBtn');
            container.classList.toggle('collapsed');
            btn.textContent = container.classList.contains('collapsed') ? '▲ Show Controls' : '▼ Hide Controls';
        });

        document.querySelectorAll('.section-header').forEach(header => {
            header.addEventListener('click', () => {
                const section = header.dataset.section;
                const content = document.querySelector(`.section-content[data-section="${section}"]`);
                const toggle = header.querySelector('.section-toggle');
                content.classList.toggle('collapsed');
                toggle.classList.toggle('collapsed');
            });
        });

        // Resizable panels
        let isResizing = false;
        let isResizingControls = false;
        let startY = 0;
        let startHeight = 0;

        const resizeHandle = document.getElementById('resize-handle');
        const timeseriesContainer = document.getElementById('timeseries-container');
        const controlsResizeHandle = document.getElementById('controls-resize-handle');
        const controlsContainer = document.getElementById('controls');

        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startY = e.clientY;
            startHeight = timeseriesContainer.offsetHeight;
            document.body.style.cursor = 'ns-resize';
            e.preventDefault();
        });

        controlsResizeHandle.addEventListener('mousedown', (e) => {
            isResizingControls = true;
            startY = e.clientY;
            startHeight = controlsContainer.offsetHeight;
            document.body.style.cursor = 'ns-resize';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const delta = startY - e.clientY;
                const newHeight = Math.max(50, startHeight + delta);
                timeseriesContainer.style.height = newHeight + 'px';
                if (window.chartUpdateTimeout) clearTimeout(window.chartUpdateTimeout);
                window.chartUpdateTimeout = setTimeout(() => {
                    if (gtData) {
                        ['chart-x', 'chart-y', 'chart-z', 'chart-error'].forEach(id => {
                            Plotly.Plots.resize(document.getElementById(id));
                        });
                    }
                }, 50);
            } else if (isResizingControls) {
                const delta = e.clientY - startY;
                const newHeight = Math.max(50, startHeight + delta);
                controlsContainer.style.maxHeight = newHeight + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing || isResizingControls) {
                isResizing = false;
                isResizingControls = false;
                document.body.style.cursor = 'default';
            }
        });

        // OrbitControls implementation
        THREE.OrbitControls = function(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.enabled = true;
            this.enableZoom = true;
            this.enableRotate = true;
            this.enablePan = true;

            const scope = this;
            const STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
            let state = STATE.NONE;

            const rotateStart = new THREE.Vector2();
            const rotateEnd = new THREE.Vector2();
            const rotateDelta = new THREE.Vector2();
            const panStart = new THREE.Vector2();
            const panEnd = new THREE.Vector2();
            const panDelta = new THREE.Vector2();
            const dollyStart = new THREE.Vector2();
            const dollyEnd = new THREE.Vector2();
            const dollyDelta = new THREE.Vector2();
            const spherical = new THREE.Spherical();
            const sphericalDelta = new THREE.Spherical();

            let scale = 1;
            const panOffset = new THREE.Vector3();
            const target = new THREE.Vector3();

            function rotateLeft(angle) { sphericalDelta.theta -= angle; }
            function rotateUp(angle) { sphericalDelta.phi -= angle; }
            function panLeft(distance, cameraMatrix) {
                const v = new THREE.Vector3();
                v.setFromMatrixColumn(cameraMatrix, 0);
                v.multiplyScalar(-distance);
                panOffset.add(v);
            }
            function panUp(distance, cameraMatrix) {
                const v = new THREE.Vector3();
                v.setFromMatrixColumn(cameraMatrix, 1);
                v.multiplyScalar(distance);
                panOffset.add(v);
            }
            function pan(deltaX, deltaY) {
                const offset = new THREE.Vector3();
                const element = scope.domElement;
                offset.copy(scope.camera.position).sub(target);
                let targetDistance = offset.length();
                targetDistance *= Math.tan((scope.camera.fov / 2) * Math.PI / 180.0);
                panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.camera.matrix);
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.camera.matrix);
            }
            function dollyIn(dollyScale) { scale /= dollyScale; }
            function dollyOut(dollyScale) { scale *= dollyScale; }

            this.update = function() {
                const offset = new THREE.Vector3();
                const quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
                const quatInverse = quat.clone().invert();

                offset.copy(scope.camera.position).sub(target);
                offset.applyQuaternion(quat);
                spherical.setFromVector3(offset);
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
                spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi));
                spherical.makeSafe();
                spherical.radius *= scale;
                target.add(panOffset);
                offset.setFromSpherical(spherical);
                offset.applyQuaternion(quatInverse);
                scope.camera.position.copy(target).add(offset);
                scope.camera.lookAt(target);
                sphericalDelta.set(0, 0, 0);
                panOffset.set(0, 0, 0);
                scale = 1;
                return false;
            };

            function onMouseDown(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                if (event.button === 0) {
                    if (!scope.enableRotate) return;
                    rotateStart.set(event.clientX, event.clientY);
                    state = STATE.ROTATE;
                } else if (event.button === 1) {
                    if (!scope.enableZoom) return;
                    dollyStart.set(event.clientX, event.clientY);
                    state = STATE.DOLLY;
                } else if (event.button === 2) {
                    if (!scope.enablePan) return;
                    panStart.set(event.clientX, event.clientY);
                    state = STATE.PAN;
                }
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            function onMouseMove(event) {
                if (!scope.enabled) return;
                event.preventDefault();
                if (state === STATE.ROTATE) {
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart);
                    rotateLeft(2 * Math.PI * rotateDelta.x / scope.domElement.clientHeight);
                    rotateUp(2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight);
                    rotateStart.copy(rotateEnd);
                    scope.update();
                } else if (state === STATE.DOLLY) {
                    dollyEnd.set(event.clientX, event.clientY);
                    dollyDelta.subVectors(dollyEnd, dollyStart);
                    if (dollyDelta.y > 0) dollyIn(0.95);
                    else if (dollyDelta.y < 0) dollyOut(0.95);
                    dollyStart.copy(dollyEnd);
                    scope.update();
                } else if (state === STATE.PAN) {
                    panEnd.set(event.clientX, event.clientY);
                    panDelta.subVectors(panEnd, panStart);
                    pan(panDelta.x, panDelta.y);
                    panStart.copy(panEnd);
                    scope.update();
                }
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                state = STATE.NONE;
            }

            function onMouseWheel(event) {
                if (!scope.enabled || !scope.enableZoom) return;
                event.preventDefault();
                if (event.deltaY < 0) dollyOut(0.95);
                else if (event.deltaY > 0) dollyIn(0.95);
                scope.update();
            }

            domElement.addEventListener('mousedown', onMouseDown);
            domElement.addEventListener('wheel', onMouseWheel);
            domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        };

        // Consistent colors for the 8 cube corners across all datasets
        const CORNER_COLORS = [
            0xff0000,  // Corner 0: Red
            0x00ff00,  // Corner 1: Green
            0x0000ff,  // Corner 2: Blue
            0xffff00,  // Corner 3: Yellow
            0xff00ff,  // Corner 4: Magenta
            0x00ffff,  // Corner 5: Cyan
            0xff8800,  // Corner 6: Orange
            0x8800ff   // Corner 7: Purple
        ];

        // State
        let currentFrame = 0;
        let isPlaying = false;
        let playSpeed = 1;
        let showGroundTruth = true;
        let showNoisy = true;
        let showKabsch = true;
        let showOptNoFilter = true;
        let showOptimized = true;
        let trailLength = 50;
        let pointSize = 0.08;
        let showGrid = true;
        let autoRotate = false;
        let showCornerTrails = false;
        let playInterval = null;

        let gtData = null;
        let noisyData = null;
        let kabschData = null;
        let optNoFilterData = null;
        let optData = null;

        let scene, camera, renderer, controls;
        let groundTruthGroup, noisyGroup, kabschGroup, optNoFilterGroup, optimizedGroup, trailsGroup, gridHelper;

        // Parse CSV
        function parseCombinedCSV(csvText) {
            const result = Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true
            });

            const gtFrames = [];
            const noisyFrames = [];
            const kabschFrames = [];
            const optNoFilterFrames = [];
            const optFrames = [];

            result.data.forEach(row => {
                const parseDataset = (prefix) => {
                    const markers = [];
                    for (let i = 0; i < 9; i++) {
                        const name = i < 8 ? `${prefix}_v${i}` : `${prefix}_center`;
                        markers.push({
                            x: row[`${name}_x`],
                            y: row[`${name}_y`],
                            z: row[`${name}_z`]
                        });
                    }
                    return { points: markers.slice(0, 8), center: markers[8] };
                };

                gtFrames.push(parseDataset('gt'));
                noisyFrames.push(parseDataset('noisy'));
                kabschFrames.push(parseDataset('kabsch'));
                optNoFilterFrames.push(parseDataset('opt_no_filter'));
                optFrames.push(parseDataset('opt'));
            });

            return { gtFrames, noisyFrames, kabschFrames, optNoFilterFrames, optFrames };
        }

        function computeFrameErrors() {
            if (!gtData || !noisyData || !kabschData || !optNoFilterData || !optData) return null;

            const noisyErrors = [];
            const kabschErrors = [];
            const optNoFilterErrors = [];
            const optErrors = [];

            for (let i = 0; i < gtData.length; i++) {
                const gtCenter = gtData[i].center;
                const noisyCenter = noisyData[i].center;
                const kabschCenter = kabschData[i].center;
                const optNoFilterCenter = optNoFilterData[i].center;
                const optCenter = optData[i].center;

                noisyErrors.push(Math.sqrt(
                    Math.pow(gtCenter.x - noisyCenter.x, 2) +
                    Math.pow(gtCenter.y - noisyCenter.y, 2) +
                    Math.pow(gtCenter.z - noisyCenter.z, 2)
                ) * 1000);

                kabschErrors.push(Math.sqrt(
                    Math.pow(gtCenter.x - kabschCenter.x, 2) +
                    Math.pow(gtCenter.y - kabschCenter.y, 2) +
                    Math.pow(gtCenter.z - kabschCenter.z, 2)
                ) * 1000);

                optNoFilterErrors.push(Math.sqrt(
                    Math.pow(gtCenter.x - optNoFilterCenter.x, 2) +
                    Math.pow(gtCenter.y - optNoFilterCenter.y, 2) +
                    Math.pow(gtCenter.z - optNoFilterCenter.z, 2)
                ) * 1000);

                optErrors.push(Math.sqrt(
                    Math.pow(gtCenter.x - optCenter.x, 2) +
                    Math.pow(gtCenter.y - optCenter.y, 2) +
                    Math.pow(gtCenter.z - optCenter.z, 2)
                ) * 1000);
            }

            return { noisyErrors, kabschErrors, optNoFilterErrors, optErrors };
        }

        function createTimeseriesCharts() {
            const frames = Array.from({length: gtData.length}, (_, i) => i);

            const layout = {
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#0f0f0f',
                font: { color: '#9ca3af', size: 11 },
                margin: { l: 50, r: 20, t: 10, b: 40 },
                xaxis: { gridcolor: '#333', title: 'Frame', color: '#9ca3af' },
                yaxis: { gridcolor: '#333', color: '#9ca3af' },
                hovermode: 'x unified',
                showlegend: true,
                legend: { x: 1, xanchor: 'right', y: 1, bgcolor: 'rgba(0,0,0,0.5)', font: { size: 10 } },
                shapes: [{
                    type: 'line',
                    x0: currentFrame,
                    x1: currentFrame,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: { color: '#fbbf24', width: 2, dash: 'dash' }
                }]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false
            };

            // X coordinate
            Plotly.newPlot('chart-x', [
                { x: frames, y: gtData.map(d => d.center.x), name: 'GT', mode: 'lines', line: { color: '#4ade80', width: 2 } },
                { x: frames, y: noisyData.map(d => d.center.x), name: 'Noisy', mode: 'lines', line: { color: '#f87171', width: 2 } },
                { x: frames, y: kabschData.map(d => d.center.x), name: 'Kabsch', mode: 'lines', line: { color: '#fbbf24', width: 2 } },
                { x: frames, y: optNoFilterData.map(d => d.center.x), name: 'Opt(raw)', mode: 'lines', line: { color: '#c084fc', width: 2 } },
                { x: frames, y: optData.map(d => d.center.x), name: 'Opt(filt)', mode: 'lines', line: { color: '#60a5fa', width: 2 } }
            ], { ...layout, yaxis: { ...layout.yaxis, title: 'X (m)' } }, config);

            // Y coordinate
            Plotly.newPlot('chart-y', [
                { x: frames, y: gtData.map(d => d.center.y), name: 'GT', mode: 'lines', line: { color: '#4ade80', width: 2 } },
                { x: frames, y: noisyData.map(d => d.center.y), name: 'Noisy', mode: 'lines', line: { color: '#f87171', width: 2 } },
                { x: frames, y: kabschData.map(d => d.center.y), name: 'Kabsch', mode: 'lines', line: { color: '#fbbf24', width: 2 } },
                { x: frames, y: optNoFilterData.map(d => d.center.y), name: 'Opt(raw)', mode: 'lines', line: { color: '#c084fc', width: 2 } },
                { x: frames, y: optData.map(d => d.center.y), name: 'Opt(filt)', mode: 'lines', line: { color: '#60a5fa', width: 2 } }
            ], { ...layout, yaxis: { ...layout.yaxis, title: 'Y (m)' } }, config);

            // Z coordinate
            Plotly.newPlot('chart-z', [
                { x: frames, y: gtData.map(d => d.center.z), name: 'GT', mode: 'lines', line: { color: '#4ade80', width: 2 } },
                { x: frames, y: noisyData.map(d => d.center.z), name: 'Noisy', mode: 'lines', line: { color: '#f87171', width: 2 } },
                { x: frames, y: kabschData.map(d => d.center.z), name: 'Kabsch', mode: 'lines', line: { color: '#fbbf24', width: 2 } },
                { x: frames, y: optNoFilterData.map(d => d.center.z), name: 'Opt(raw)', mode: 'lines', line: { color: '#c084fc', width: 2 } },
                { x: frames, y: optData.map(d => d.center.z), name: 'Opt(filt)', mode: 'lines', line: { color: '#60a5fa', width: 2 } }
            ], { ...layout, yaxis: { ...layout.yaxis, title: 'Z (m)' } }, config);

            // Errors
            const errorData = computeFrameErrors();
            Plotly.newPlot('chart-error', [
                { x: frames, y: errorData.noisyErrors, name: 'Noisy', mode: 'lines', line: { color: '#f87171', width: 2 } },
                { x: frames, y: errorData.kabschErrors, name: 'Kabsch', mode: 'lines', line: { color: '#fbbf24', width: 2 } },
                { x: frames, y: errorData.optNoFilterErrors, name: 'Opt(raw)', mode: 'lines', line: { color: '#c084fc', width: 2 } },
                { x: frames, y: errorData.optErrors, name: 'Opt(filt)', mode: 'lines', line: { color: '#60a5fa', width: 2 } }
            ], { ...layout, yaxis: { ...layout.yaxis, title: 'Error (mm)' } }, config);
        }

        function updateChartFrameIndicators() {
            ['chart-x', 'chart-y', 'chart-z', 'chart-error'].forEach(id => {
                Plotly.relayout(id, {
                    'shapes[0].x0': currentFrame,
                    'shapes[0].x1': currentFrame
                });
            });
        }

        function loadCSVData(csvText) {
            const { gtFrames, noisyFrames, kabschFrames, optNoFilterFrames, optFrames } = parseCombinedCSV(csvText);

            gtData = gtFrames;
            noisyData = noisyFrames;
            kabschData = kabschFrames;
            optNoFilterData = optNoFilterFrames;
            optData = optFrames;

            const numFrames = gtFrames.length;
            document.getElementById('frameSlider').max = numFrames - 1;
            document.getElementById('totalFrames').textContent = numFrames - 1;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('frameSlider').disabled = false;
            document.getElementById('trailLengthSlider').max = numFrames;

            document.getElementById('loading').style.display = 'none';

            initThreeJS();
            createTimeseriesCharts();
            updateVisualization();
        }

        async function autoLoadCSV() {
            try {
                const response = await fetch('trajectory_data.csv');
                if (!response.ok) throw new Error('File not found');
                const csvText = await response.text();
                loadCSVData(csvText);
                document.getElementById('dataStatus').textContent = '✓ Auto-loaded trajectory_data.csv';
                document.getElementById('dataStatus').classList.add('loaded');
            } catch (error) {
                console.log('Auto-load failed:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('dataStatus').textContent = '⚠ Auto-load failed - please upload CSV';
                document.getElementById('dataStatus').classList.add('error');
            }
        }

        document.getElementById('csvFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loadingText').textContent = 'Loading CSV...';
            const reader = new FileReader();
            reader.onload = (event) => {
                loadCSVData(event.target.result);
                document.getElementById('dataStatus').textContent = `✓ Loaded ${file.name}`;
                document.getElementById('dataStatus').classList.remove('error');
                document.getElementById('dataStatus').classList.add('loaded');
            };
            reader.readAsText(file);
        });

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            groundTruthGroup = new THREE.Group();
            noisyGroup = new THREE.Group();
            kabschGroup = new THREE.Group();
            optNoFilterGroup = new THREE.Group();
            optimizedGroup = new THREE.Group();
            trailsGroup = new THREE.Group();

            scene.add(groundTruthGroup);
            scene.add(noisyGroup);
            scene.add(kabschGroup);
            scene.add(optNoFilterGroup);
            scene.add(optimizedGroup);
            scene.add(trailsGroup);

            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            function animate() {
                requestAnimationFrame(animate);
                if (autoRotate) {
                    camera.position.x = camera.position.x * 0.999 + (8 * Math.cos(Date.now() * 0.0001)) * 0.001;
                    camera.position.z = camera.position.z * 0.999 + (8 * Math.sin(Date.now() * 0.0001)) * 0.001;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });
        }

        function createRigidBody(body, lineColor, centerColor) {
            const group = new THREE.Group();

            // Create corner spheres with consistent colors
            body.points.forEach((p, i) => {
                const geometry = new THREE.SphereGeometry(pointSize, 16, 16);
                const material = new THREE.MeshStandardMaterial({ color: CORNER_COLORS[i] });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(p.x, p.y, p.z);
                group.add(sphere);
            });

            // Create center sphere
            const centerGeometry = new THREE.SphereGeometry(pointSize * 1.5, 16, 16);
            const centerMaterial = new THREE.MeshStandardMaterial({ color: centerColor });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            centerSphere.position.set(body.center.x, body.center.y, body.center.z);
            group.add(centerSphere);

            // Create edges with dataset-specific colors
            const edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7],
            ];

            edges.forEach(([i, j]) => {
                const points = [
                    new THREE.Vector3(body.points[i].x, body.points[i].y, body.points[i].z),
                    new THREE.Vector3(body.points[j].x, body.points[j].y, body.points[j].z),
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: lineColor,
                    opacity: 0.6,
                    transparent: true
                });
                const line = new THREE.Line(geometry, material);
                group.add(line);
            });

            return group;
        }

        function updateVisualization() {
            if (!gtData || !noisyData || !kabschData || !optNoFilterData || !optData) return;

            groundTruthGroup.clear();
            noisyGroup.clear();
            kabschGroup.clear();
            optNoFilterGroup.clear();
            optimizedGroup.clear();
            trailsGroup.clear();

            if (showGroundTruth) {
                const gt = createRigidBody(gtData[currentFrame], 0x00aa00, 0x00ff00);
                groundTruthGroup.add(gt);
            }

            if (showKabsch) {
                const kabsch = createRigidBody(kabschData[currentFrame], 0xd97706, 0xfbbf24);
                kabschGroup.add(kabsch);
            }

            if (showOptNoFilter) {
                const optNoFilter = createRigidBody(optNoFilterData[currentFrame], 0xa855f7, 0xc084fc);
                optNoFilterGroup.add(optNoFilter);
            }

            if (showOptimized) {
                const opt = createRigidBody(optData[currentFrame], 0x0055aa, 0x0088ff);
                optimizedGroup.add(opt);
            }

            if (showNoisy) {
                const noisy = createRigidBody(noisyData[currentFrame], 0xaa0000, 0xff0000);
                noisy.renderOrder = 1;
                noisyGroup.add(noisy);
            }

            // Create center trails
            function createCenterTrail(data, color, show) {
                if (!show || trailLength === 0) return;
                const points = [];
                for (let i = Math.max(0, currentFrame - trailLength); i <= currentFrame; i++) {
                    const p = data[i].center;
                    points.push(new THREE.Vector3(p.x, p.y, p.z));
                }
                if (points.length > 1) {
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color,
                        opacity: 0.4,
                        transparent: true
                    });
                    const line = new THREE.Line(geometry, material);
                    trailsGroup.add(line);
                }
            }

            createCenterTrail(gtData, 0x00ff00, showGroundTruth);
            createCenterTrail(noisyData, 0xff0000, showNoisy);
            createCenterTrail(kabschData, 0xfbbf24, showKabsch);
            createCenterTrail(optNoFilterData, 0xc084fc, showOptNoFilter);
            createCenterTrail(optData, 0x0088ff, showOptimized);

            // Create corner trails
            function createCornerTrails(data, show) {
                if (!show || !showCornerTrails || trailLength === 0) return;

                for (let cornerIdx = 0; cornerIdx < 8; cornerIdx++) {
                    const points = [];
                    for (let i = Math.max(0, currentFrame - trailLength); i <= currentFrame; i++) {
                        const p = data[i].points[cornerIdx];
                        points.push(new THREE.Vector3(p.x, p.y, p.z));
                    }
                    if (points.length > 1) {
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: CORNER_COLORS[cornerIdx],
                            opacity: 0.3,
                            transparent: true
                        });
                        const line = new THREE.Line(geometry, material);
                        trailsGroup.add(line);
                    }
                }
            }

            createCornerTrails(gtData, showGroundTruth);
            createCornerTrails(noisyData, showNoisy);
            createCornerTrails(kabschData, showKabsch);
            createCornerTrails(optNoFilterData, showOptNoFilter);
            createCornerTrails(optData, showOptimized);

            gridHelper.visible = showGrid;

            document.getElementById('currentFrame').textContent = currentFrame;
            updateChartFrameIndicators();
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').innerHTML = isPlaying ? '⏸ Pause' : '▶ Play';

            if (isPlaying) {
                const maxFrame = parseInt(document.getElementById('frameSlider').max);
                playInterval = setInterval(() => {
                    currentFrame = (currentFrame + 1) % (maxFrame + 1);
                    document.getElementById('frameSlider').value = currentFrame;
                    updateVisualization();
                }, 33 / playSpeed);
            } else {
                clearInterval(playInterval);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            currentFrame = 0;
            isPlaying = false;
            clearInterval(playInterval);
            document.getElementById('playBtn').innerHTML = '▶ Play';
            document.getElementById('frameSlider').value = 0;
            updateVisualization();
        });

        document.getElementById('frameSlider').addEventListener('input', (e) => {
            currentFrame = parseInt(e.target.value);
            updateVisualization();
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            playSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = playSpeed;
            if (isPlaying) {
                clearInterval(playInterval);
                const maxFrame = parseInt(document.getElementById('frameSlider').max);
                playInterval = setInterval(() => {
                    currentFrame = (currentFrame + 1) % (maxFrame + 1);
                    document.getElementById('frameSlider').value = currentFrame;
                    updateVisualization();
                }, 33 / playSpeed);
            }
        });

        document.getElementById('showGroundTruth').addEventListener('change', (e) => {
            showGroundTruth = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showNoisy').addEventListener('change', (e) => {
            showNoisy = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showKabsch').addEventListener('change', (e) => {
            showKabsch = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showOptNoFilter').addEventListener('change', (e) => {
            showOptNoFilter = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showOptimized').addEventListener('change', (e) => {
            showOptimized = e.target.checked;
            updateVisualization();
        });

        document.getElementById('trailLengthSlider').addEventListener('input', (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailLengthValue').textContent = trailLength;
            updateVisualization();
        });

        document.getElementById('pointSizeSlider').addEventListener('input', (e) => {
            pointSize = parseFloat(e.target.value);
            document.getElementById('pointSizeValue').textContent = pointSize;
            updateVisualization();
        });

        document.getElementById('showGridCheckbox').addEventListener('change', (e) => {
            showGrid = e.target.checked;
            updateVisualization();
        });

        document.getElementById('autoRotateCheckbox').addEventListener('change', (e) => {
            autoRotate = e.target.checked;
        });

        document.getElementById('showCornerTrailsCheckbox').addEventListener('change', (e) => {
            showCornerTrails = e.target.checked;
            updateVisualization();
        });

        window.addEventListener('load', autoLoadCSV);
    </script>
</body>
</html>
